#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import requests
import threading
import argparse
import time
import random
from queue import Queue
import sys
from urllib.parse import urlparse, urljoin

# --- Konfigurasi Warna untuk Output ---
class Colors:
    """Kelas untuk menyimpan kode warna ANSI."""
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ORANGE = '\033[38;5;208m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# --- Daftar User-Agent Default ---
DEFAULT_USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15",
    "Mozilla/5.0 (X11; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1"
]

# --- Inisialisasi Antrian dan Kunci ---
url_queue = Queue()
print_lock = threading.Lock()
found_count = 0
processed_count = 0
total_paths = 0
output_file_handle = None
original_wordlist_for_recursion = [] # Untuk menyimpan wordlist asli untuk rekursi

# --- Fungsi untuk Menampilkan Banner ---
def display_banner(no_color_flag):
    """Menampilkan banner aplikasi."""
    banner_text = """
======================================================================
                        R E C O N H A W K
======================================================================
                         Simple & Fast
                        ReconHawk v1.1
    """
    if no_color_flag:
        print(banner_text)
    else:
        print(f"{Colors.ORANGE}{banner_text}{Colors.ENDC}")
    print("-" * 70)

# --- Fungsi untuk Melakukan Request HTTP ---
def check_path(target_url, path_to_check, current_depth, args_namespace):
    """
    Memeriksa path tertentu pada target URL.
    Args:
        target_url (str): URL dasar target.
        path_to_check (str): Path yang akan diperiksa (bisa tuple (path, depth) untuk rekursi).
        current_depth (int): Kedalaman rekursi saat ini untuk path ini.
        args_namespace (argparse.Namespace): Namespace argumen dari parser.
    """
    global found_count, processed_count, total_paths, output_file_handle, original_wordlist_for_recursion

    full_url = urljoin(target_url, path_to_check.lstrip('/'))
    user_agent = random.choice(args_namespace.user_agents_list) # Ambil dari namespace

    try:
        headers = {'User-Agent': user_agent}
        response = requests.get(full_url, headers=headers, timeout=args_namespace.timeout, allow_redirects=True, verify=True)
        
        status_code = response.status_code
        content_length = len(response.content)

        with print_lock:
            processed_count += 1
            progress_percent = (processed_count / total_paths) * 100 if total_paths > 0 else 0
            # Pesan progres yang lebih informatif, termasuk kedalaman jika rekursif
            progress_msg = f"Progres: {processed_count}/{total_paths} ({progress_percent:.2f}%)"
            if args_namespace.recursive:
                progress_msg += f" | Kedalaman Saat Ini: {current_depth}"
            progress_msg += f" | Ditemukan: {found_count}"

            sys.stdout.write(f"\r{Colors.BLUE if not args_namespace.no_color else ''}{progress_msg}{Colors.ENDC if not args_namespace.no_color else ''}")
            sys.stdout.flush()

            if status_code in args_namespace.interesting_status_codes_list:
                found_count += 1
                output_line = f"[{time.strftime('%H:%M:%S')}] [{status_code}] {full_url} (Ukuran: {content_length} B)"
                
                # Simpan ke file jika diminta
                if output_file_handle:
                    output_file_handle.write(output_line + "\n")
                    output_file_handle.flush() # Pastikan langsung ditulis

                # Tampilkan ke konsol
                if args_namespace.no_color:
                    print("\n" + output_line)
                else:
                    color_code = Colors.ENDC
                    if 200 <= status_code < 300: color_code = Colors.GREEN
                    elif 300 <= status_code < 400: color_code = Colors.YELLOW
                    elif status_code == 403: color_code = Colors.RED
                    elif status_code == 401: color_code = Colors.ORANGE
                    elif 400 <= status_code < 500: color_code = Colors.BLUE
                    elif 500 <= status_code < 600: color_code = Colors.RED + Colors.BOLD
                    print(f"\n{color_code}{output_line}{Colors.ENDC}")
                
                # Logika Rekursi
                # Cek apakah ini direktori (biasanya status 200 dan diakhiri dengan '/')
                # atau jika status redirect (301, 302) ke path yang diakhiri '/'
                is_directory_like = (path_to_check.endswith('/') and status_code in [200, 204, 401, 403]) or \
                                    (status_code in [301, 302, 307] and response.url.endswith('/'))

                if args_namespace.recursive and is_directory_like and current_depth < args_namespace.recursion_depth:
                    # print(f"\n{Colors.BLUE if not args_namespace.no_color else ''}[RECURSIVE] Menemukan direktori: {full_url} pada kedalaman {current_depth}. Memulai scan rekursif...{Colors.ENDC if not args_namespace.no_color else ''}")
                    for entry in original_wordlist_for_recursion:
                        # Bentuk path baru relatif terhadap direktori yang ditemukan
                        new_recursive_path = urljoin(path_to_check, entry.lstrip('/'))
                        url_queue.put((new_recursive_path, current_depth + 1))
                        total_paths += 1 # Perbarui total path karena ada path baru dari rekursi
            
            if args_namespace.delay > 0:
                time.sleep(args_namespace.delay)

    except requests.exceptions.RequestException:
        with print_lock:
            processed_count += 1 # Tetap hitung sebagai terproses
            # (opsional: log error ke file atau konsol jika verbose)
    except Exception:
        with print_lock:
            processed_count += 1 # Tetap hitung sebagai terproses
            # (opsional: log error)

# --- Fungsi Worker untuk Thread ---
def worker(target_url, args_namespace_for_worker):
    """Fungsi yang dijalankan oleh setiap thread."""
    while not url_queue.empty():
        try:
            # Item antrian sekarang adalah tuple (path, depth)
            path_item, depth_item = url_queue.get(timeout=1) 
            check_path(target_url, path_item, depth_item, args_namespace_for_worker)
            url_queue.task_done()
        except Queue.Empty: 
            break 
        except Exception as e:
            with print_lock:
                # Cetak error worker jika perlu, tapi hindari terlalu verbose
                # print(f"\n{Colors.RED if not args_namespace_for_worker.no_color else ''}Error di worker: {e}{Colors.ENDC if not args_namespace_for_worker.no_color else ''}")
                pass
            url_queue.task_done() # Pastikan task_done dipanggil meskipun ada error

# --- Fungsi Utama ---
def main():
    """Fungsi utama untuk menjalankan alat."""
    global total_paths, output_file_handle, original_wordlist_for_recursion

    parser = argparse.ArgumentParser(description="ReconHawk - Alat Reconnaissance Web berbasis Python.")
    parser.add_argument("-u", "--url", required=True, help="URL target (contoh: http://example.com)")
    parser.add_argument("-w", "--wordlist", required=True, help="Path ke file wordlist")
    parser.add_argument("-t", "--threads", type=int, default=10, help="Jumlah thread yang akan digunakan (default: 10)")
    parser.add_argument("-a", "--user-agent", help="User-Agent kustom. Jika tidak disetel, akan dipilih secara acak dari daftar default.")
    parser.add_argument("-x", "--extensions", help="Ekstensi file yang akan ditambahkan, dipisahkan koma (contoh: php,html,txt)")
    parser.add_argument("-s", "--status-codes", default="200,204,301,302,307,401,403,500", help="Status code yang dianggap menarik, dipisahkan koma (default: 200,204,301,302,307,401,403,500)")
    parser.add_argument("--timeout", type=int, default=10, help="Waktu timeout untuk request dalam detik (default: 10)")
    parser.add_argument("--delay", type=float, default=0, help="Waktu tunda antar request per thread dalam detik (default: 0)")
    parser.add_argument("--no-color", action="store_true", help="Nonaktifkan output berwarna")
    parser.add_argument("-o", "--output", help="Nama file untuk menyimpan hasil output (contoh: found_paths.txt)")
    parser.add_argument("-r", "--recursive", action="store_true", help="Aktifkan scanning rekursif pada direktori yang ditemukan")
    parser.add_argument("-d", "--recursion-depth", type=int, default=2, help="Kedalaman maksimum untuk scanning rekursif (default: 2, hanya berlaku jika --recursive aktif)")


    args = parser.parse_args()

    display_banner(args.no_color)

    # Simpan user agents list ke dalam args namespace untuk akses mudah di worker/check_path
    if args.user_agent:
        args.user_agents_list = [args.user_agent]
    else:
        args.user_agents_list = DEFAULT_USER_AGENTS
    
    # Simpan interesting status codes list ke dalam args namespace
    try:
        args.interesting_status_codes_list = [int(code.strip()) for code in args.status_codes.split(',')]
    except ValueError:
        print(f"{Colors.RED if not args.no_color else ''}[!] Format status code tidak valid. Harap gunakan angka yang dipisahkan koma.{Colors.ENDC if not args.no_color else ''}")
        sys.exit(1)


    if not args.url.startswith("http://") and not args.url.startswith("https://"):
        print(f"{Colors.RED if not args.no_color else ''}[!] URL tidak valid. Harap sertakan skema (http:// atau https://).{Colors.ENDC if not args.no_color else ''}")
        sys.exit(1)
    
    target_url = args.url if args.url.endswith('/') else args.url + '/'

    # Buka file output jika nama file diberikan
    if args.output:
        try:
            output_file_handle = open(args.output, "w", encoding='utf-8')
            print(f"{Colors.BLUE if not args.no_color else ''}[*] Hasil akan disimpan di: {args.output}{Colors.ENDC if not args.no_color else ''}")
        except IOError as e:
            print(f"{Colors.RED if not args.no_color else ''}[!] Tidak dapat membuka file output {args.output}: {e}{Colors.ENDC if not args.no_color else ''}")
            output_file_handle = None # Set ke None jika gagal dibuka

    extensions_to_check = []
    if args.extensions:
        extensions_to_check = [ext.strip().lstrip('.') for ext in args.extensions.split(',')] 

    try:
        with open(args.wordlist, "r", encoding='utf-8', errors='ignore') as f:
            # Simpan wordlist asli untuk rekursi
            original_wordlist_for_recursion = [line.strip() for line in f if line.strip()]
        if not original_wordlist_for_recursion: # Cek jika wordlist kosong setelah dibaca
            raise ValueError("Wordlist kosong.")
    except FileNotFoundError:
        print(f"{Colors.RED if not args.no_color else ''}[!] File wordlist tidak ditemukan: {args.wordlist}{Colors.ENDC if not args.no_color else ''}")
        sys.exit(1)
    except ValueError as e:
        print(f"{Colors.RED if not args.no_color else ''}[!] Error: {e}{Colors.ENDC if not args.no_color else ''}")
        sys.exit(1)

    # Mengisi antrian awal dengan path dari wordlist (kedalaman 0)
    for path_entry in original_wordlist_for_recursion:
        # Item antrian adalah tuple (path, depth)
        url_queue.put((path_entry, 0)) # Kedalaman awal 0
        if not path_entry.endswith('/'):
             url_queue.put((path_entry + "/", 0))

        if extensions_to_check:
            for ext in extensions_to_check:
                url_queue.put((f"{path_entry}.{ext}", 0))

    total_paths = url_queue.qsize()
    if total_paths == 0:
        print(f"{Colors.YELLOW if not args.no_color else ''}[!] Wordlist kosong atau tidak ada path yang valid untuk diproses.{Colors.ENDC if not args.no_color else ''}")
        sys.exit(0)

    print(f"{Colors.HEADER if not args.no_color else ''}[*] Target URL          : {target_url}{Colors.ENDC if not args.no_color else ''}")
    print(f"{Colors.HEADER if not args.no_color else ''}[*] Wordlist            : {args.wordlist}{Colors.ENDC if not args.no_color else ''}")
    print(f"{Colors.HEADER if not args.no_color else ''}[*] Threads             : {args.threads}{Colors.ENDC if not args.no_color else ''}")
    print(f"{Colors.HEADER if not args.no_color else ''}[*] Rekursif            : {'Aktif' if args.recursive else 'Tidak Aktif'}{Colors.ENDC if not args.no_color else ''}")
    if args.recursive:
        print(f"{Colors.HEADER if not args.no_color else ''}[*] Kedalaman Rekursi   : {args.recursion_depth}{Colors.ENDC if not args.no_color else ''}")
    print(f"{Colors.HEADER if not args.no_color else ''}[*] Total path awal     : {total_paths}{Colors.ENDC if not args.no_color else ''}")
    print("-" * 70)
    print(f"{Colors.BLUE if not args.no_color else ''}[{time.strftime('%H:%M:%S')}] Memulai proses scanning...{Colors.ENDC if not args.no_color else ''}")

    start_time = time.time()

    threads = []
    for _ in range(args.threads):
        # Kirim seluruh namespace args ke worker
        thread = threading.Thread(target=worker, args=(target_url, args), daemon=True)
        threads.append(thread)
        thread.start()

    url_queue.join()
    
    end_time = time.time()
    
    sys.stdout.write("\r" + " " * 100 + "\r") # Hapus baris progres yang lebih panjang
    sys.stdout.flush()

    print(f"\n{Colors.BLUE if not args.no_color else ''}[{time.strftime('%H:%M:%S')}] Scanning selesai dalam {end_time - start_time:.2f} detik.{Colors.ENDC if not args.no_color else ''}")
    print(f"{Colors.GREEN if not args.no_color else ''}[+] Total ditemukan: {found_count} path/file.{Colors.ENDC if not args.no_color else ''}")
    if output_file_handle:
        print(f"{Colors.BLUE if not args.no_color else ''}[*] Hasil juga disimpan di: {args.output}{Colors.ENDC if not args.no_color else ''}")
        output_file_handle.close()
    print("-" * 70)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n\n{Colors.YELLOW if '--no-color' not in sys.argv else ''}[!] Proses dihentikan oleh pengguna.{Colors.ENDC if '--no-color' not in sys.argv else ''}")
        if output_file_handle: # Pastikan file ditutup jika ada interupsi
            output_file_handle.close()
        sys.exit(0)
